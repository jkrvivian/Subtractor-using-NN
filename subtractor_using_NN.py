# -*- coding: utf-8 -*-
"""subtractor with NN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XCXllZ4rrCCDQNSsoZ8ZsQlcuQhrIqwU

# subtractor using NN
This project implements a 3-digit subtractor using NN

## policy
To increase the prediction accuracy, I will use binary to represent data.

## import libraries
"""

import numpy as np                                                                          
from random import randint
from keras.models import Sequential 
from keras.layers import Dense

"""## Generate training data and validation data
After rendering a 3-digit number, I transfer it to binary representation.
"""

class GenTestSet():
  def  __init__(self):
    self.train_prob = []
    self.train_ans = []
    self.val_prob = []
    self.val_ans = []

  def binStr2binInt(self, bin_str):
    ret = []
    for x in bin_str:
      if x == "0":
        ret.append(0)
      else:
        ret.append(1)
    return ret

  def gen(self):
    num_len = 3
    num_min = 10 ** (num_len - 1)
    num_max = 10 ** num_len - 1
    ret_len = 120000
    ans = 0
    problem = 0
    
    for i in range(0, ret_len):
        a, b = randint(num_min, num_max), randint(num_min, num_max)
        c, d = randint(num_min, num_max), randint(num_min, num_max)

        # training data
        a_bin, b_bin = self.binStr2binInt("{:010b}".format(a)), self.binStr2binInt("{:010b}".format(b))   

        if a > b:
          problem = a_bin + b_bin
          ans = self.binStr2binInt("{:010b}".format(a - b))
        else:
          problem = b_bin + a_bin
          ans = self.binStr2binInt("{:010b}".format(b - a))
          
        self.train_ans.append(ans)
        self.train_prob.append(problem)

        # validation data
        c_bin, d_bin = self.binStr2binInt("{:010b}".format(c)), self.binStr2binInt("{:010b}".format(d))

        if c > d:
          problem = c_bin + d_bin
          ans = self.binStr2binInt("{:010b}".format(c - d))
        else:
          problem = d_bin + c_bin
          ans = self.binStr2binInt("{:010b}".format(d - c))
          
        self.val_ans.append(ans)
        self.val_prob.append(problem)
    
    return

"""## Create datasets"""

testset = GenTestSet()
testset.gen()
np.array(testset.train_ans)

"""## Define model with Keras"""

model = Sequential()
model.add(Dense(300, input_shape=(20,), activation='relu'))
model.add(Dense(200, activation='relu'))
model.add(Dense(100, activation='relu'))
model.add(Dense(50, activation='relu'))
model.add(Dense(10, activation='sigmoid'))

"""## Compile model"""

model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

"""## Fit model"""

model.fit(np.array(testset.train_prob), np.array(testset.train_ans), epochs=150, batch_size=10)

"""## Evaluate training result
Use the validation data generated before
"""

# generate predictions
predictions = model.predict(np.array(testset.val_prob))
#print(predictions)

for i in range(0, len(predictions)):
  for j in range(0, 10):
    if predictions[i][j] > 0.5:
      predictions[i][j] = 1
    else:
      predictions[i][j] = 0
      
correct = 0
error = 0
# compare to correct answer

for i in range(0, len(testset.val_ans)):
  for j in range(0, 10):
    if predictions[i][j] != testset.val_ans[i][j]:
      error = error + 1
      break
    if j == 9:
      correct = correct + 1
      

print("accuracy rate: ", correct / float(len(predictions)))