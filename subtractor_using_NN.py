# -*- coding: utf-8 -*-
"""subtractor using NN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XCXllZ4rrCCDQNSsoZ8ZsQlcuQhrIqwU
"""

import numpy as np                                                                          
from random import randint
from keras.models import Sequential 
from keras.layers import Dense

# Generate training data and validation data
class GenTestSet():
  def  __init__(self):
    self.train_prob = []
    self.train_ans = []
    self.val_prob = []
    self.val_ans = []
    self.val_prob_dec = []
    self.val_ans_dec = []

  def binStr2binInt(self, bin_str):
    ret = []
    for x in bin_str:
      if x == "0":
        ret.append(0)
      else:
        ret.append(1)
    return ret

  def gen(self):
    num_len = 3
    num_min = 10 ** (num_len - 1)
    num_max = 10 ** num_len - 1
    ret_len = 100000
    ans = 0
    problem = 0
    prob_str = ""
    ans_str = ""
    
    for i in range(0, ret_len):
        a, b = randint(num_min, num_max), randint(num_min, num_max)
        c, d = randint(num_min, num_max), randint(num_min, num_max)

        # training data
        a_bin, b_bin = self.binStr2binInt("{:010b}".format(a)), self.binStr2binInt("{:010b}".format(b))   

        if a > b:
          problem = a_bin + b_bin
          ans = self.binStr2binInt("{:010b}".format(a - b))
        else:
          problem = b_bin + a_bin
          ans = self.binStr2binInt("{:010b}".format(b - a))
          
        self.train_ans.append(ans)
        self.train_prob.append(problem)

        # validation data
        c_bin, d_bin = self.binStr2binInt("{:010b}".format(c)), self.binStr2binInt("{:010b}".format(d))

        if c > d:
          problem = c_bin + d_bin
          prob_str = str(c) + "-" + str(d)
          ans_str = str(c - d)
          ans = self.binStr2binInt("{:010b}".format(c - d))
        else:
          problem = d_bin + c_bin
          prob_str = str(d) + "-" + str(c)   
          ans_str = str(d - c)
          ans = self.binStr2binInt("{:010b}".format(d - c))
          
        self.val_ans.append(ans)
        self.val_prob.append(problem)
        self.val_prob_dec.append(prob_str)
        self.val_ans_dec.append(ans_str)
    return

# Create datasets

testset = GenTestSet()
testset.gen()
np.array(testset.train_ans)

# Define model with Keras"

model = Sequential()
model.add(Dense(300, input_shape=(20,), activation='relu'))
model.add(Dense(200, activation='relu'))
model.add(Dense(100, activation='relu'))
model.add(Dense(50, activation='relu'))
model.add(Dense(10, activation='sigmoid'))

# Compile model
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

# Fit model
model.fit(np.array(testset.train_prob), np.array(testset.train_ans), epochs=150, batch_size=100)

# generate predictions
predict = model.predict(np.array(testset.val_prob))

predictions = []
for i in range(0, len(predict)):
  tmp = []
  for j in range(0, 10):
    if predict[i][j] > 0.5:
      tmp.append(1)
    else:
      tmp.append(0)
  predictions.append(tmp)
  
      
# transfer binary to decimal
predict_dec = []
for i in range(0, len(predictions)):
  ans = 0
  for j in range(0, 10):
    ans = ans + (2 ** (9 - j)) * predictions[i][j]
  predict_dec.append(ans)


# compare to correct answer and calculate correctness and errors
correct = 0
error = 0

for i in range(0, len(testset.val_ans)):
  print(testset.val_prob_dec[i], testset.val_ans_dec[i], predict_dec[i])
  #print(testset.val_ans[i])
  #print(predictions[i])
  #print("\n")
  for j in range(0, 10):
    if predictions[i][j] != testset.val_ans[i][j]:
      error = error + 1
      break
    if j == 9:
      correct = correct + 1

# calculate accuracy rate
print("accuracy rate: ", correct / float(len(predictions)))
